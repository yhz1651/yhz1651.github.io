<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>项目作品集</title>
    <link href="/2025/02/17/yhz_project/"/>
    <url>/2025/02/17/yhz_project/</url>
    
    <content type="html"><![CDATA[<h3 id="OJ在线判题系统"><a href="#OJ在线判题系统" class="headerlink" title="OJ在线判题系统"></a>OJ在线判题系统</h3><p>项目介绍：在线编程评测系统，实现代码自动评测功能。系统核心模块代码沙箱服务使用模块化设计，支持独立调用。</p><p>技术栈：Vue3 + SpringBoot + Docker + RabbitMQ + Spring Cloud</p><p>项目地址：</p><hr><h3 id="校园交友平台"><a href="#校园交友平台" class="headerlink" title="校园交友平台"></a>校园交友平台</h3><p>项目介绍：校园在线交友平台，包含发帖、活动预约、在线聊天、好友推荐、权限管理等功能。</p><p>技术栈：Vue3 + SpringBoot + Mybatis-Plus + Sa-token + Redis</p><p>项目地址：<a href="https://github.com/yhz1651/campus-partner">https://github.com/yhz1651/campus-partner</a></p><hr><h3 id="航天五院态势感知项目"><a href="#航天五院态势感知项目" class="headerlink" title="航天五院态势感知项目"></a>航天五院态势感知项目</h3><p>项目介绍：战场态势感知系统，实现态势语义描述、态势自动推理、军事意图识别、态势预测量化评估等功能。</p><p>技术栈：Vue3 + Flask + Pytorch</p><p>项目地址：涉密项目，不开源</p><hr><h3 id="Android音乐APP"><a href="#Android音乐APP" class="headerlink" title="Android音乐APP"></a>Android音乐APP</h3><p>项目介绍：音乐播放器，包含歌曲搜索、播放、收藏、下载、评论、歌单创建等功能。</p><p>技术栈：Android + SpringBoot</p><p>项目地址：</p><ul><li>Android端：<a href="https://github.com/yhz1651/MusicApp">https://github.com/yhz1651/MusicApp</a></li><li>后端：<a href="https://github.com/yhz1651/MusicApp-backend">https://github.com/yhz1651/MusicApp-backend</a></li></ul><hr><h3 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a>图书管理系统</h3><p>项目介绍：图书管理系统，包含图书管理、借阅管理、用户管理等功能。</p><p>技术栈：Vue2 + SpringBoot + Mybatis</p><p>项目地址：<a href="https://github.com/yhz1651/library_management">https://github.com/yhz1651/library_management</a></p><hr><h3 id="研究生推免系统"><a href="#研究生推免系统" class="headerlink" title="研究生推免系统"></a>研究生推免系统</h3><p>项目介绍：研究生推免报名系统，包含报名、审核、统计等功能。</p><p>技术栈：Bootstrap + SpringBoot</p><p>项目地址：<a href="https://github.com/yhz1651/tuimian">https://github.com/yhz1651/tuimian</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2025/02/13/MySQL/"/>
    <url>/2025/02/13/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2025/02/13/Redis/"/>
    <url>/2025/02/13/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2025/02/13/Java_base/"/>
    <url>/2025/02/13/Java_base/</url>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2025/02/13/C++_base/"/>
    <url>/2025/02/13/C++_base/</url>
    
    <content type="html"><![CDATA[<p>本文针对初学者，介绍 C++ 的基本使用，包括控制语句、标准库的常用数据结构等。</p><h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>C++ 的标准输出是 <code>cout</code>，用 <code>&lt;&lt;</code> 运算符把需要打印的内容传递给 <code>cout</code>，<code>endl</code> 是换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 输出：10</span><br>cout &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// 可以串联输出</span><br><span class="hljs-comment">// 输出：Hello, World!</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-string">&quot;World!&quot;</span> &lt;&lt; endl;<br><br>string s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">// 输出：abc 10</span><br>cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>当然，C 语言的 <code>printf</code> 函数也可以用，但是 <code>cout</code> 更加方便，所以我们一般用 <code>cout</code>。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>编程语言的控制语句一般都比较简单，最常见的无非就是条件判断和循环，下面简单介绍一下。</p><h3 id="条件判断-if-else"><a href="#条件判断-if-else" class="headerlink" title="条件判断 if else"></a>条件判断 if else</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">5</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a &gt; 5&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">5</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a == 5&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a &lt; 5&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 输出：a &gt; 5</span><br></code></pre></td></tr></table></figure><h3 id="循环-for-while"><a href="#循环-for-while" class="headerlink" title="循环 for&#x2F;while"></a>循环 for&#x2F;while</h3><p>for 和 while 都可以用来做循环，for 循环一般用于已知循环次数的情况，while 循环一般用于未知循环次数的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 0 1 2 3 4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// 100 50 25 12 6 3 1</span><br><span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>    cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    num /= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>对于标准库的常用数据结构，力扣平台都会默认导入。也就是说，你在写算法题是，可以直接使用 <code>vector</code>、<code>set</code>、<code>map</code> 等关键字创建数据结构。</p><h3 id="动态数组-vector"><a href="#动态数组-vector" class="headerlink" title="动态数组 vector"></a>动态数组 <code>vector</code></h3><p><code>vector</code> 是 C++ 标准库的动态数组。</p><p>大家以前学 C 语言的时候肯定学过 <code>malloc, int[n]</code> 等方式来创建静态数组，但是这种方式非常麻烦，而且容易出错。我们做算法题的时候一般使用动态数组 <code>vector</code>，而且题目给的输入一般也是 <code>vector</code> 类型。</p><p><code>vector</code> 的初始化方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">7</span>, m = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 初始化一个 int 型的空数组 nums</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br><span class="hljs-comment">// 初始化一个大小为 n 的数组 nums，数组中的值默认都为 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br><br><span class="hljs-comment">// 初始化一个元素为 1, 3, 5 的数组 nums</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化一个大小为 n 的数组 nums，其值全都为 2</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n, <span class="hljs-number">2</span>)</span></span>;<br><br><span class="hljs-comment">// 初始化一个二维 int 数组 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dp;<br><br><span class="hljs-comment">// 初始化一个大小为 m * n 的布尔数组 dp，</span><br><span class="hljs-comment">// 其中的值都初始化为 true</span><br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">true</span>));<br></code></pre></td></tr></table></figure><p><code>vector</code> 的常用操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 数组大小为 10，元素值都为 0</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-comment">// 输出 0 (false)</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出：10</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 在数组尾部插入一个元素 20</span><br>    nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">// 输出：11</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 得到数组最后一个元素的引用</span><br>    <span class="hljs-comment">// 输出：20</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除数组的最后一个元素（无返回值）</span><br>    nums.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// 输出：10</span><br>    cout &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 可以通过方括号直接取值或修改</span><br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>;<br>    <span class="hljs-comment">// 输出：11</span><br>    cout &lt;&lt; nums[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 在索引 3 处插入一个元素 99</span><br>    nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, <span class="hljs-number">99</span>);<br><br>    <span class="hljs-comment">// 删除索引 2 处的元素</span><br>    nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 交换 nums[0] 和 nums[1]</span><br>    <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-comment">// 0 11 99 0 0 0 0 0 0 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是 C++ <code>vector</code> 在本书中的常用方法，无非就是用索引取元素以及 <code>push_back, pop_back</code> 方法，就刷算法题而言，这些就够了。</p><p>因为根据「数组」的特性，利用索引访问元素很高效，从尾部增删元素也是很高效的；而从中间或头部增删元素要涉及搬移数据，很低效。</p><h3 id="双链表-list"><a href="#双链表-list" class="headerlink" title="双链表 list"></a>双链表 <code>list</code></h3><p><code>list</code> 是 C++ 标准库中的双向链表容器。</p><p>初始化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">7</span>;<br><br><span class="hljs-comment">// 初始化一个空的双向链表 lst</span><br>std::list&lt;<span class="hljs-type">int</span>&gt; lst;<br><br><span class="hljs-comment">// 初始化一个大小为 n 的链表 lst，链表中的值默认都为 0</span><br><span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst</span><span class="hljs-params">(n)</span></span>;<br><br><span class="hljs-comment">// 初始化一个包含元素 1, 3, 5 的链表 lst</span><br>std::list&lt;<span class="hljs-type">int</span>&gt; lst&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化一个大小为 n 的链表 lst，其中值都为 2</span><br><span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst</span><span class="hljs-params">(n, <span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><code>list</code> 的常用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化链表</span><br>    list&lt;<span class="hljs-type">int</span>&gt; lst&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 检查链表是否为空，输出：false</span><br>    cout &lt;&lt; lst.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取链表的大小，输出：5</span><br>    cout &lt;&lt; lst.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 在链表头部插入元素 0</span><br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 在链表尾部插入元素 6</span><br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 获取链表头部和尾部元素，输出：0 6</span><br>    cout &lt;&lt; lst.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除链表头部元素</span><br>    lst.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-comment">// 删除链表尾部元素</span><br>    lst.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-comment">// 在链表中插入元素</span><br>    <span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 移动到第三个位置</span><br>    <span class="hljs-built_in">advance</span>(it, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 在第三个位置插入 99</span><br>    lst.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">99</span>);<br><br>    <span class="hljs-comment">// 删除链表中某个元素</span><br>    it = lst.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 移动到第二个位置</span><br>    <span class="hljs-built_in">advance</span>(it, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 删除第二个位置的元素</span><br>    lst.<span class="hljs-built_in">erase</span>(it);<br><br>    <span class="hljs-comment">// 遍历链表</span><br>    <span class="hljs-comment">// 输出：1 99 3 4 5</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : lst) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，当我们想在头部增删元素时会使用双链表，因为它在头部增删元素的效率比 <code>vector</code> 高。但我们通过索引访问元素，这种场景下我们会使用 <code>vector</code>。</p><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 <code>queue</code></h3><p><code>queue</code> 是 C++ 标准库中的队列容器，基于先进先出（FIFO）的原则。队列适用于只允许从一端（队尾）添加元素、从另一端（队头）移除元素的场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化一个空的整型队列 q</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-comment">// 在队尾添加元素</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 检查队列是否为空，输出：false</span><br>    cout &lt;&lt; q.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取队列的大小，输出：3</span><br>    cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取队列的队头和队尾元素，输出：10 和 30</span><br>    cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除队头元素</span><br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 输出新的队头元素：20</span><br>    cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 <code>stack</code></h3><p>栈是一种后进先出（LIFO）的数据结构，栈适用于只允许在一端（栈顶）添加或移除元素的场景。</p><p><code>stack</code> 是 C++ 标准库中的栈容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化一个空的整型栈 s</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 向栈顶添加元素</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 检查栈是否为空，输出：false</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取栈的大小，输出：3</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取栈顶元素，输出：30</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除栈顶元素</span><br>    s.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 输出新的栈顶元素：20</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 unordered_map"></a>哈希表 <code>unordered_map</code></h3><p><code>unordered_map</code> 是 C++ 标准库中的一种哈希表实现，它提供了基于键值对（key-value）的存储，提供了常数时间复杂度的查找、插入和删除键值对的操作。</p><p>初始化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 初始化一个空的哈希表 map</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; hashmap;<br><br><span class="hljs-comment">// 初始化一个包含一些键值对的哈希表 map</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; hashmap&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p><code>unordered_map</code> 的常用方法如下。</p><p>特别注意：访问不存在的键会自动插入键值对！</p><p><strong>在 C++ 的哈希表中，如果你访问一个不存在的键，它会自动创建这个键，对应的值是默认构造的值</strong>。</p><p>这一点和其他语言不同，需要格外注意。记住访问值之前要先判断键是否存在，否则可能会意外地创建新键，导致算法出错。详见下面的示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化哈希表</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; hashmap&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 检查哈希表是否为空，输出：0 (false)</span><br>    cout &lt;&lt; hashmap.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取哈希表的大小，输出：3</span><br>    cout &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 查找指定键是否存在</span><br>    <span class="hljs-comment">// 注意 contains 方法是 C++20 新增的</span><br>    <span class="hljs-comment">// 输出：Key 2 -&gt; two</span><br>    <span class="hljs-keyword">if</span> (hashmap.<span class="hljs-built_in">contains</span>(<span class="hljs-number">2</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Key 2 -&gt; &quot;</span> &lt;&lt; hashmap[<span class="hljs-number">2</span>] &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Key 2 not found.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定键对应的值，若不存在会返回默认构造的值</span><br>    <span class="hljs-comment">// 输出空字符串</span><br>    cout &lt;&lt; hashmap[<span class="hljs-number">4</span>] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 插入一个新的键值对</span><br>    hashmap[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;four&quot;</span>;<br><br>    <span class="hljs-comment">// 获取新插入的值，输出：four</span><br>    cout &lt;&lt; hashmap[<span class="hljs-number">4</span>] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除键值对</span><br>    hashmap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 检查删除后键 3 是否存在</span><br>    <span class="hljs-comment">// 输出：Key 3 not found.</span><br>    <span class="hljs-keyword">if</span> (hashmap.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Key 3 -&gt; &quot;</span> &lt;&lt; hashmap[<span class="hljs-number">3</span>] &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Key 3 not found.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历哈希表</span><br>    <span class="hljs-comment">// 输出（顺序可能不同）：</span><br>    <span class="hljs-comment">// 4 -&gt; four</span><br>    <span class="hljs-comment">// 2 -&gt; two</span><br>    <span class="hljs-comment">// 1 -&gt; one</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;pair: hashmap) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 特别注意，访问不存在的键会自动创建这个键</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; hashmap2;<br><br>    <span class="hljs-comment">// 键值对的数量是 0</span><br>    cout &lt;&lt; hashmap<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// 访问不存在的键，会自动创建这个键，对应的值是默认构造的值</span><br>    cout &lt;&lt; hashmap2[<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// empty string</span><br>    cout &lt;&lt; hashmap2[<span class="hljs-number">2</span>] &lt;&lt; endl; <span class="hljs-comment">// empty string</span><br><br>    <span class="hljs-comment">// 现在键值对的数量是 2</span><br>    cout &lt;&lt; hashmap<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希集合-unordered-set"><a href="#哈希集合-unordered-set" class="headerlink" title="哈希集合 unordered_set"></a>哈希集合 <code>unordered_set</code></h3><p><code>unordered_set</code> 是 C++ 标准库中的一种哈希集合实现，用于存储不重复的元素，常见使用场景是对元素进行去重。</p><p>初始化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 初始化一个空的哈希集合 set</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br><br><span class="hljs-comment">// 初始化一个包含一些元素的哈希集合 set</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; uset&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br></code></pre></td></tr></table></figure><p><code>unordered_set</code> 的常用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化哈希集合</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hashset&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><br>    <span class="hljs-comment">// 检查哈希集合是否为空，输出：0 (false)</span><br>    cout &lt;&lt; hashset.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取哈希集合的大小，输出：4</span><br>    cout &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 查找指定元素是否存在</span><br>    <span class="hljs-comment">// 输出：Element 3 found.</span><br>    <span class="hljs-keyword">if</span> (hashset.<span class="hljs-built_in">contains</span>(<span class="hljs-number">3</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Element 3 found.&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Element 3 not found.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入一个新的元素</span><br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 删除一个元素</span><br>    hashset.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 输出：Element 2 not found.</span><br>    <span class="hljs-keyword">if</span> (hashset.<span class="hljs-built_in">contains</span>(<span class="hljs-number">2</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Element 2 found.&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Element 2 not found.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历哈希集合</span><br>    <span class="hljs-comment">// 输出（顺序可能不同）：</span><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;element : hashset) &#123;<br>        cout &lt;&lt; element &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 <code>priority_queue</code></h3><p><code>priority_queue</code>是一种特殊的队列，队列中的元素按优先级排列，每次取出优先级最高的元素。C++ 中的优先队列基于堆实现，默认是最大堆，也可以自定义为最小堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 最大堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 查看堆顶元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Top element of Max-Heap: &quot;</span> &lt;&lt; maxHeap.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除堆顶元素</span><br>    maxHeap.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Max-Heap is empty&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Max-Heap is not empty&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取堆的大小</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Size of Max-Heap: &quot;</span> &lt;&lt; maxHeap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 最小堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 查看堆顶元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Top element of Min-Heap: &quot;</span> &lt;&lt; minHeap.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 删除堆顶元素</span><br>    minHeap.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-keyword">if</span> (minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Min-Heap is empty&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Min-Heap is not empty&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取堆的大小</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Size of Min-Heap: &quot;</span> &lt;&lt; minHeap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 <code>String</code></h3><h3 id="对-pair"><a href="#对-pair" class="headerlink" title="对 pair"></a>对 <code>pair</code></h3><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 sort"></a>排序 <code>sort</code></h3><p><code>sort</code> 是 C++ 标准库中的一个算法，用于对容器中的元素进行排序，可以对数组、向量、列表等容器进行排序。默认按升序排序，可以自定义比较函数，实现降序或其他排序规则，排序范围由两个迭代器指定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 包含 sort 函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个向量</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><br>    <span class="hljs-comment">// 默认升序排序</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 使用默认比较函数</span><br><br>    <span class="hljs-comment">// 输出排序后的结果</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sorted in ascending order: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 降序排序</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// 使用自定义比较函数</span><br><br>    <span class="hljs-comment">// 输出排序后的结果</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sorted in descending order: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，<code>sort</code> 按升序排序，但也可以通过自定义比较函数实现降序或其他排序规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b; <span class="hljs-comment">// 降序排序</span><br>&#125;<br><br><span class="hljs-comment">// 自定义比较函数用于结构体排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a, <span class="hljs-type">const</span> Student&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.score &gt; b.score; <span class="hljs-comment">// 按分数降序排序</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 对整数向量进行排序</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 使用自定义比较函数降序排序</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sorted integers in descending order: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 对结构体向量进行排序</span><br>    vector&lt;Student&gt; students = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">85</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">92</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">78</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">95</span>&#125;<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), cmpStudent); <span class="hljs-comment">// 按分数降序排序</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sorted students by score in descending order:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; student : students) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; student.id &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; student.score &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找-lower-bound-upper-bound"><a href="#二分查找-lower-bound-upper-bound" class="headerlink" title="二分查找 lower_bound &amp; upper_bound"></a>二分查找 <code>lower_bound &amp; upper_bound</code></h3><h2 id="传值和传引用"><a href="#传值和传引用" class="headerlink" title="传值和传引用"></a>传值和传引用</h2><p>在 C++ 中，函数参数的传递方式主要有两种：<strong>传值</strong>和<strong>传引用</strong>。理解它们的区别对于编写高效的算法代码至关重要，特别是在处理大量数据或需要修改原始数据时。</p><h3 id="传值（Pass-by-Value）"><a href="#传值（Pass-by-Value）" class="headerlink" title="传值（Pass by Value）"></a>传值（Pass by Value）</h3><p><strong>传值</strong>是指将函数参数的一个副本传递给函数，在函数内部对该副本的修改不会影响到原始数据。</p><p>下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 只修改副本，不会影响原始数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">modifyValue</span>(num);<br>    <span class="hljs-comment">// 输出：5</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;After modifyValue, num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>num</code> 的值在调用 <code>modifyValue</code> 后并未改变，因为传入的是 <code>num</code> 的副本，函数内的修改仅影响副本。</p><h4 id="传引用（Pass-by-Reference）"><a href="#传引用（Pass-by-Reference）" class="headerlink" title="传引用（Pass by Reference）"></a>传引用（Pass by Reference）</h4><p><strong>传引用</strong>是指将实参的地址传递给函数，函数可以直接操作原始数据。这意味着对参数的修改会直接影响原始数据。</p><p>下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyReference</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>    x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 修改原始数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">modifyReference</span>(num);<br>    <span class="hljs-comment">// 输出：10</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;After modifyReference, num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>num</code> 的值被修改为 10，因为我们传递的是 <code>num</code> 的引用，函数内对 <code>x</code> 的修改直接影响了 <code>num</code>。</p><h3 id="做算法题时的选择"><a href="#做算法题时的选择" class="headerlink" title="做算法题时的选择"></a>做算法题时的选择</h3><p>以我的经验，如果是传递基本类型，比如 <code>int</code>、<code>bool</code> 等，用传值比较多，因为这类数据一般不需要在函数内部修改，而且复制得开销很小。</p><p>如果是传递容器，比如 <code>vector</code>、<code>unordered_map</code> 等，用传引用比较多，因为可以避免复制数据副本的开销，而且容器一般需要在函数内部修改。</p><p>特别注意一个可能出现的问题，就是递归函数的参数千万别使用传值的方式，否则每次递归都会创建一个数据副本，消耗大量的内存和时间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ 官方文档地址：<a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></p><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-回溯</title>
    <link href="/2025/02/13/algorithm_backtrack/"/>
    <url>/2025/02/13/algorithm_backtrack/</url>
    
    <content type="html"><![CDATA[<h2 id="子集型回溯-组合型回溯"><a href="#子集型回溯-组合型回溯" class="headerlink" title="子集型回溯&#x2F;组合型回溯"></a>子集型回溯&#x2F;组合型回溯</h2><p>每个元素<strong>选或者不选</strong></p><p><strong>方法1 输入的视角（选或不选）</strong></p><p><img src="/images/dfs1.png" alt="方法1：选或不选"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 递归边界</span><br>        res.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 加入答案</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 返回上一层</span><br>    &#125;<br>    <span class="hljs-comment">// 选</span><br>    path.<span class="hljs-built_in">push_back</span>(nums[i]); <br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归下一层</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 恢复现场</span><br>    <br>    <span class="hljs-comment">// 不选</span><br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法2 答案的视角（枚举每个位置选哪个元素）</strong></p><p>枚举每个位置应该选哪个元素，并且不能重复，只能从前往后选，不能回头。</p><p><img src="/images/dfs2.png" alt="方法2：枚举选哪个元素"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 每一个都是答案，本体特殊，所有节点都是答案，正常情况下只有叶子节点是答案，需要if判断</span><br>    res.<span class="hljs-built_in">push_back</span>(path); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 从下一个元素开始遍历，确保不重复</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>        <span class="hljs-built_in">dfs</span>(j + <span class="hljs-number">1</span>, nums); <span class="hljs-comment">// 递归下一层</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 恢复现场</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTrack</span> <span class="hljs-params">(可选列表，已走路径)</span>：</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(满足结束条件)</span></span>&#123;<br>        allPath.<span class="hljs-built_in">add</span>(已走路径);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(选择：可选列表)&#123;<br>        做选择<br>        backTrack（当前可选列表，已走路径）;<br>        撤销选择<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="排列型回溯"><a href="#排列型回溯" class="headerlink" title="排列型回溯"></a>排列型回溯</h2><p>需要用到<strong>集合</strong>或者<strong>哈希表</strong>记录已经选择过的元素，在回溯时也需要<strong>恢复现场</strong></p><p><strong>只能用枚举的方法，不适用选或不选的方法！</strong></p><p><img src="/images/dfs3.png" alt="排列型回溯"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (vis[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果访问过就不访问</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>        vis[j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, nums); <span class="hljs-comment">// 递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <br>        vis[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 都需要恢复现场</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-二分查找</title>
    <link href="/2025/02/13/algorithm_binarysearch/"/>
    <url>/2025/02/13/algorithm_binarysearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-二叉树</title>
    <link href="/2025/02/13/algorithm_binarytree/"/>
    <url>/2025/02/13/algorithm_binarytree/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-双指针</title>
    <link href="/2025/02/13/algorithm_doublepointer/"/>
    <url>/2025/02/13/algorithm_doublepointer/</url>
    
    <content type="html"><![CDATA[<h2 id="双向双指针"><a href="#双向双指针" class="headerlink" title="双向双指针"></a>双向双指针</h2><p>适用于<strong>有序数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>    <span class="hljs-comment">// 当前操作</span><br>    <span class="hljs-type">int</span> sum = numbers[i] + numbers[j];<br>    <span class="hljs-comment">// 判断条件，移动左右指针</span><br>    <span class="hljs-keyword">if</span> (sum == target) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) j--;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) i++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="同向双指针（滑动窗口）"><a href="#同向双指针（滑动窗口）" class="headerlink" title="同向双指针（滑动窗口）"></a>同向双指针（滑动窗口）</h2><p>适用于<strong>连续子数组、子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-keyword">for</span> (right = <span class="hljs-number">0</span>; right &lt; n; right++) &#123;<br>    <span class="hljs-comment">// right元素的操作</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; <span class="hljs-built_in">check</span>()) &#123; <span class="hljs-comment">// 区间[left,right]不符合题意</span><br>        <span class="hljs-comment">// left元素的操作</span><br>        left++; <span class="hljs-comment">// 拓展左边界</span><br>    &#125;<br>    <span class="hljs-comment">// 区间[left,right]符合题意，统计相关信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-链表</title>
    <link href="/2025/02/13/algorithm_linkedlist/"/>
    <url>/2025/02/13/algorithm_linkedlist/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-动态规划</title>
    <link href="/2025/02/13/algorithm_dp/"/>
    <url>/2025/02/13/algorithm_dp/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><img src="/images/test.png" alt="浙江大学"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="/2025/02/13/Markdown_base/"/>
    <url>/2025/02/13/Markdown_base/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h1 id="标题-1"><a href="#标题-1" class="headerlink" title="标题 1"></a>标题 1</h1><h2 id="标题-2"><a href="#标题-2" class="headerlink" title="标题 2"></a>标题 2</h2><h3 id="标题-3"><a href="#标题-3" class="headerlink" title="标题 3"></a>标题 3</h3><h4 id="标题-4"><a href="#标题-4" class="headerlink" title="标题 4"></a>标题 4</h4><h5 id="标题-5"><a href="#标题-5" class="headerlink" title="标题 5"></a>标题 5</h5><h6 id="标题-6"><a href="#标题-6" class="headerlink" title="标题 6"></a>标题 6</h6><p><strong>加粗文本</strong><br><em>斜体文本</em><br><del>删除线文本</del><br><code>行内代码</code></p><hr><blockquote><p>引用文本<br>多行引用</p></blockquote><ol><li>有序列表项 1</li><li>有序列表项 2</li><li>有序列表项 3</li></ol><ul><li>无序列表项 1</li><li>无序列表项 2</li><li>无序列表项 3</li></ul><table><thead><tr><th>表头 1</th><th>表头 2</th><th>表头 3</th></tr></thead><tbody><tr><td>单元格 1</td><td>单元格 2</td><td>单元格 3</td></tr><tr><td>单元格 4</td><td>单元格 5</td><td>单元格 6</td></tr></tbody></table><ul><li><input checked="" disabled="" type="checkbox"> 任务 1</li><li><input disabled="" type="checkbox"> 任务 2</li><li><input disabled="" type="checkbox"> 任务 3</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 代码块</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure><p><a href="https://yhz1651.github.io/">文本链接</a>  </p><p><img src="/images/test.png" alt="图片引用"></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
